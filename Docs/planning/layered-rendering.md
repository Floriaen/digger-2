# Layered Rendering Plan

## Why Revisit Rendering
- Overlay sprites bleed across chunk boundaries and require ad hoc ordering fixes.
- Dig-darkening, darkness components, and block overlays compete for draw order in the chunk loop.
- Adding new visual systems (particles, props, UI hooks) risks reintroducing z-order bugs.
- Current logic binds rendering tightly to terrain traversal, making reuse in other systems difficult.

## Goals
- Provide a small, explicit set of render layers (background, terrain-base, terrain-overlay, entities, effects, HUD).
- Centralize draw ordering so all systems follow the same rules.
- Preserve existing geometry metadata (width/height/offset) while decoupling it from terrain-specific pipelines.
- Keep performance reasonable for large numbers of draw calls.

## Proposed Architecture
1. **RenderLayer Enum**: Define an ordered list of layers. Example order: `BACKGROUND < TERRAIN_BASE < TERRAIN_OVERLAY < ENTITIES < EFFECTS < HUD`.
2. **RenderQueue Service**:
   - Exposes `queueDraw({ layer, depth, spriteX, spriteY, width, height, destX, destY, alpha, textureId, type, reuseKey })`.
     - `textureId` lets multi-atlas content choose the correct sprite sheet without reworking callers later.
     - `type` defaults to `sprite`; other values (e.g., `fill-rect`) support primitives like dig-darkening quads.
     - `reuseKey` is optional but documents the intent to pool command objects and avoid per-frame GC churn.
   - Stores commands in per-layer buckets for cache-friendly sorting.
   - Each frame, `flush(ctx, spriteSheets, camera)` sorts buckets by `depth` (default: world Y or explicit value), applies camera offsets to `destX/destY`, executes draws, and then clears/recycles the buckets.
3. **Component Updates**:
   - `RenderComponent` keeps geometry data. Add optional `layer` and `depthOffset` fields for blocks/entities that supply their own layer.
   - Terrain blocks default to `TERRAIN_BASE`; overlay layers generated by `RenderComponent` queue to `TERRAIN_OVERLAY`.
4. **System Responsibilities**:
   - `TerrainComponent`: iterates blocks, queues base and overlay commands (no direct drawing). Calculates `depth = worldY * TILE_HEIGHT + layer.offsetDepth` to maintain bottom-to-top order.
   - Camera-aware systems pass camera offsets when computing `destX/destY` so cross-chunk draws remain stable during scrolling.
   - `BackgroundComponent`, `GridOverlayComponent`, HUD, etc., push their visuals to the queue using appropriate layers.
   - Potential entity systems (player, falling rocks) queue into `ENTITIES`.
5. **Flush Sequence**:
   - At the end of the frame, a central renderer (e.g., `RenderQueue.flush`) walks layers in enum order, sorts by depth, and draws.

## Migration Steps
1. **Infrastructure**: Implement `RenderLayer` constants and `RenderQueue`. Wire queue instance into `Game` context.
2. **Terrain Refactor**:
   - Replace immediate draw calls with queueing base and overlay instructions.
   - Move darkening/dig shading into queue using the `type: "fill-rect"` command path (or similar) for semi-transparent primitives.
3. **Component Adoption**:
   - Update systems (`BackgroundComponent`, `GridOverlayComponent`, HUD) to use the queue.
   - Ensure existing offsets and alpha handling carry over without visual regression.
4. **Testing**:
   - Visual regression pass on chunk boundaries, digging, darkness overlays.
   - Stress test with stacked overlays, wide sprites, and GUI elements.
   - Run a synthetic perf test that floods the queue with mixed layers to ensure sort/flush costs stay within budget.
5. **Cleanup**:
   - Remove obsolete row-level overlay queues.
   - Document layer usage in `DEV_TOOLS.md` or a dedicated rendering guide.

## Open Questions
- Does `type: "fill-rect"` cover all planned non-sprite primitives, or do we anticipate needing additional command shapes?
- Should `RenderQueue` support batching per sprite atlas region for performance, or is naive draw sufficient for current scope?
- How should dynamic entities (player, particles) supply depthâ€”grid-based, camera-relative, or explicit z index?
- Is there a need for developer tooling (debug overlay) to visualize queued commands per layer during testing?

## Next Actions
1. Prototype `RenderQueue` and layer enum.
2. Convert terrain rendering to queue-based drawing.
3. Run visual regression and adjust depth heuristics as needed.
